/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "A2_M" {
    code {
        codecopy(0, dataoffset("A2_M_deployed"), datasize("A2_M_deployed"))
        return(0, datasize("A2_M_deployed"))
    }
    object "A2_M_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                case 0x27a15f43
                {
                    // add_two_number(uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$u64_u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_add_two_number(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$u64_u64$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x30df35a9
                {
                    // arithmetic_ops(uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_arithmetic_ops(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$u64_u64$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xae7d00ae
                {
                    // bool_ops(uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$u64_u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_bool_ops(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool_bool$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xf1a0a85c
                {
                    // div(uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$u64_u64$(4, calldatasize())
                    let ret_0, ret_1 := A2_M_div(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$u64_u64$(memPos, ret_0, ret_1)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x4c275efc
                {
                    // multiple_ops(uint64,uint64,uint64)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$u64_u64_u64$(4, calldatasize())
                    let ret_0 := A2_M_multiple_ops(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xdc75bec7
                {
                    // underflow()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_M_underflow()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                default {}
            }
            $Abort(97)
            function A2_M_add_two_number(x, y) -> $result0, $result1 {
                let res, z, $t4, $t5
                // $t4 := +($t0, $t1)
                /// @src 2:283:284
                $t4 := $AddU64(x, y)
                // $t5 := 3
                /// @src 2:303:304
                $t5 := 3
                // return ($t5, $t4)
                /// @src 2:308:316
                $result0 := $t5
                $result1 := $t4
            }

            function A2_M_arithmetic_ops(a) -> $result0, $result1 {
                let c, $t2, $t3, $t4, $t5
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t5 := 42
                        /// @src 2:2232:2234
                        $t5 := 42
                        // abort($t5)
                        /// @src 2:2226:2234
                        $Abort($t5)
                    }
                    case 3 {
                        // label L2
                        // return ($t2, $t0)
                        /// @src 2:2244:2250
                        $result0 := $t2
                        $result1 := a
                        leave
                    }
                    case 4 {
                        // $t2 := 2
                        /// @src 2:2181:2204
                        $t2 := 2
                        // $t3 := 2
                        /// @src 2:2223:2224
                        $t3 := 2
                        // $t4 := !=($t2, $t3)
                        /// @src 2:2220:2222
                        $t4 := $Neq($t2, $t3)
                        // if ($t4) goto L0 else goto L2
                        /// @src 2:2214:2234
                        switch $t4
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_M_bool_ops(a, b) -> $result0, $result1 {
                let tmp_$2, tmp_$3, c, d, $t6, $t7, $t8, $t9, $t10, $t11, $t12
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t2 := >=($t0, $t1)
                        /// @src 2:1806:1808
                        tmp_$2 := $GtEq(a, b)
                        // goto L3
                        /// @src 2:1795:1810
                        $block := 5
                    }
                    case 3 {
                        // label L2
                        // $t7 := false
                        /// @src 2:1795:1810
                        $t7 := false
                        // $t2 := $t7
                        /// @src 2:1795:1810
                        tmp_$2 := $t7
                        // goto L3
                        /// @src 2:1795:1810
                        $block := 5
                    }
                    case 4 {
                        // $t6 := >($t0, $t1)
                        /// @src 2:1797:1798
                        $t6 := $Gt(a, b)
                        // if ($t6) goto L0 else goto L2
                        /// @src 2:1795:1810
                        switch $t6
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                    case 5 {
                        // label L3
                        // $t8 := <($t0, $t1)
                        /// @src 2:1826:1827
                        $t8 := $Lt(a, b)
                        // if ($t8) goto L4 else goto L6
                        /// @src 2:1824:1839
                        switch $t8
                        case 0  { $block := 7 }
                        default { $block := 6 }
                    }
                    case 6 {
                        // label L4
                        // $t9 := true
                        /// @src 2:1824:1839
                        $t9 := true
                        // $t3 := $t9
                        /// @src 2:1824:1839
                        tmp_$3 := $t9
                        // goto L7
                        /// @src 2:1824:1839
                        $block := 8
                    }
                    case 7 {
                        // label L6
                        // $t3 := <=($t0, $t1)
                        /// @src 2:1835:1837
                        tmp_$3 := $LtEq(a, b)
                        // goto L7
                        /// @src 2:1824:1839
                        $block := 8
                    }
                    case 8 {
                        // label L7
                        // $t10 := !=($t2, $t3)
                        /// @src 2:1857:1859
                        $t10 := $Neq(tmp_$2, tmp_$3)
                        // $t11 := !($t10)
                        /// @src 2:1853:1854
                        $t11 := $LogicalNot($t10)
                        // if ($t11) goto L8 else goto L10
                        /// @src 2:1849:1872
                        switch $t11
                        case 0  { $block := 10 }
                        default { $block := 9 }
                    }
                    case 9 {
                        // label L8
                        // $t12 := 42
                        /// @src 2:1870:1872
                        $t12 := 42
                        // abort($t12)
                        /// @src 2:1864:1872
                        $Abort($t12)
                    }
                    case 10 {
                        // label L10
                        // return ($t2, $t3)
                        /// @src 2:1882:1888
                        $result0 := tmp_$2
                        $result1 := tmp_$3
                        leave
                    }
                }
            }

            function A2_M_div(x, y) -> $result0, $result1 {
                let $t2, $t3
                // $t2 := /($t0, $t1)
                /// @src 2:848:849
                $t2 := $Div(x, y)
                // $t3 := %($t0, $t1)
                /// @src 2:855:856
                $t3 := $Mod(x, y)
                // return ($t2, $t3)
                /// @src 2:845:859
                $result0 := $t2
                $result1 := $t3
            }

            function A2_M_multiple_ops(x, y, z) -> $result {
                let $t3, $t4
                // $t3 := *($t1, $t2)
                /// @src 2:1358:1359
                $t3 := $MulU64(y, z)
                // $t4 := +($t0, $t3)
                /// @src 2:1354:1355
                $t4 := $AddU64(x, $t3)
                // return $t4
                /// @src 2:1352:1361
                $result := $t4
            }

            function A2_M_underflow() -> $result {
                let x, $t1, $t2, $t3
                // $t1 := 0
                /// @src 2:2521:2522
                $t1 := 0
                // $t2 := 1
                /// @src 2:2536:2537
                $t2 := 1
                // $t3 := -($t1, $t2)
                /// @src 2:2534:2535
                $t3 := $Sub($t1, $t2)
                // return $t3
                /// @src 2:2532:2537
                $result := $t3
            }

            function abi_encode_tuple_$u64$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_u64(value_0, add(headStart, 0))
            }
            function abi_encode_u64(value, pos) {
                mstore(pos, cleanup_u64(value))
            }
            function cleanup_u64(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffff)
            }
            function abi_decode_tuple_$u64_u64_u64$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_u64(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_u64(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_u64(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_u64(offset, end) -> value {
                value := calldataload(offset)
                validator_u64(value)
            }
            function validator_u64(value) {
                if iszero(eq(value, cleanup_u64(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$u64_u64$(headStart ,value_0, value_1) -> tail {
                tail := add(headStart, 64)
                abi_encode_u64(value_0, add(headStart, 0))
                abi_encode_u64(value_1, add(headStart, 32))
            }
            function abi_decode_tuple_$u64_u64$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_u64(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_u64(add(headStart, offset), dataEnd)
                }
            }
            function abi_encode_tuple_$bool_bool$(headStart ,value_0, value_1) -> tail {
                tail := add(headStart, 64)
                abi_encode_bool(value_0, add(headStart, 0))
                abi_encode_bool(value_1, add(headStart, 32))
            }
            function abi_encode_bool(value, pos) {
                mstore(pos, cleanup_bool(value))
            }
            function cleanup_bool(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_decode_tuple_$u64$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_u64(add(headStart, offset), dataEnd)
                }
            }
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $AbortBuiltin() {
                $Abort(sub(0, 1))
            }
            function $AddU64(x, y) -> r {
                if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $MulU64(x, y) -> r {
                if gt(y, div(0xffffffffffffffff, x)) { $AbortBuiltin() }
                r := mul(x, y)
            }
            function $Sub(x, y) -> r {
                if lt(x, y) { $AbortBuiltin() }
                r := sub(x, y)
            }
            function $Div(x, y) -> r {
                if eq(y, 0) { $AbortBuiltin() }
                r := div(x, y)
            }
            function $Mod(x, y) -> r {
                if eq(y, 0) { $AbortBuiltin() }
                r := mod(x, y)
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
            function $Gt(x, y) -> r {
                r := gt(x, y)
            }
            function $Lt(x, y) -> r {
                r := lt(x, y)
            }
            function $GtEq(x, y) -> r {
                r := or(gt(x, y), eq(x, y))
            }
            function $LtEq(x, y) -> r {
                r := or(lt(x, y), eq(x, y))
            }
            function $Neq(x, y) -> r {
                r := not(eq(x, y))
            }
            function $LogicalNot(x) -> r {
                r := not(x)
            }
        }
    }
}


!! Succeeded compiling Yul


!! Unit tests

// test of M::test_add_two_number
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_add_two_number" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_add_two_number()
        return (0, 0)
        function A2_M_test_add_two_number() {
            let res, z, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    /// @src 2:425:428
                    $t8 := 100
                    // abort($t8)
                    /// @src 2:409:429
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 7
                    /// @src 2:451:452
                    $t9 := 7
                    // $t10 := ==($t5, $t9)
                    /// @src 2:448:450
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    /// @src 2:436:458
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 2
                    /// @src 2:397:398
                    $t2 := 2
                    // $t3 := 5
                    /// @src 2:400:401
                    $t3 := 5
                    // ($t4, $t5) := M::add_two_number($t2, $t3)
                    /// @src 2:382:402
                    $t4, $t5 := A2_M_add_two_number($t2, $t3)
                    // $t6 := 3
                    /// @src 2:422:423
                    $t6 := 3
                    // $t7 := ==($t4, $t6)
                    /// @src 2:419:421
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    /// @src 2:409:429
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    /// @src 2:454:457
                    $t11 := 101
                    // abort($t11)
                    /// @src 2:436:458
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    /// @src 2:458:459
                    leave
                }
            }
        }

        function A2_M_add_two_number(x, y) -> $result0, $result1 {
            let res, z, $t4, $t5
            // $t4 := +($t0, $t1)
            /// @src 2:283:284
            $t4 := $AddU64(x, y)
            // $t5 := 3
            /// @src 2:303:304
            $t5 := 3
            // return ($t5, $t4)
            /// @src 2:308:316
            $result0 := $t5
            $result1 := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Succeed(Stopped) (used_gas=355): []

// test of M::test_add_two_number_overflow
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_add_two_number_overflow" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_add_two_number_overflow()
        return (0, 0)
        function A2_M_test_add_two_number_overflow() {
            let _res, _z, $t2, $t3, $t4, $t5
            // $t2 := 18446744073709551615
            /// @src 2:710:730
            $t2 := 18446744073709551615
            // $t3 := 1
            /// @src 2:732:733
            $t3 := 1
            // ($t4, $t5) := M::add_two_number($t2, $t3)
            /// @src 2:695:734
            $t4, $t5 := A2_M_add_two_number($t2, $t3)
            // destroy($t5)
            /// @src 2:687:691
            // destroy($t4)
            /// @src 2:683:685
            // return ()
            /// @src 2:734:735
        }

        function A2_M_add_two_number(x, y) -> $result0, $result1 {
            let res, z, $t4, $t5
            // $t4 := +($t0, $t1)
            /// @src 2:283:284
            $t4 := $AddU64(x, y)
            // $t5 := 3
            /// @src 2:303:304
            $t5 := 3
            // return ($t5, $t4)
            /// @src 2:308:316
            $result0 := $t5
            $result1 := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
    }
}
===> Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]

// test of M::test_add_two_number_wrong_assert
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_add_two_number_wrong_assert" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_add_two_number_wrong_assert()
        return (0, 0)
        function A2_M_test_add_two_number_wrong_assert() {
            let res, z, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    /// @src 2:581:584
                    $t8 := 100
                    // abort($t8)
                    /// @src 2:565:585
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 6
                    /// @src 2:607:608
                    $t9 := 6
                    // $t10 := ==($t5, $t9)
                    /// @src 2:604:606
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    /// @src 2:592:614
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 2
                    /// @src 2:553:554
                    $t2 := 2
                    // $t3 := 5
                    /// @src 2:556:557
                    $t3 := 5
                    // ($t4, $t5) := M::add_two_number($t2, $t3)
                    /// @src 2:538:558
                    $t4, $t5 := A2_M_add_two_number($t2, $t3)
                    // $t6 := 3
                    /// @src 2:578:579
                    $t6 := 3
                    // $t7 := ==($t4, $t6)
                    /// @src 2:575:577
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    /// @src 2:565:585
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    /// @src 2:610:613
                    $t11 := 101
                    // abort($t11)
                    /// @src 2:592:614
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    /// @src 2:614:615
                    leave
                }
            }
        }

        function A2_M_add_two_number(x, y) -> $result0, $result1 {
            let res, z, $t4, $t5
            // $t4 := +($t0, $t1)
            /// @src 2:283:284
            $t4 := $AddU64(x, y)
            // $t5 := 3
            /// @src 2:303:304
            $t5 := 3
            // return ($t5, $t4)
            /// @src 2:308:316
            $result0 := $t5
            $result1 := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Revert(Reverted) (used_gas=356): [0, 0, 0, 0, 0, 0, 0, 101]

// test of M::test_arithmetic_ops_aborts
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_arithmetic_ops_aborts" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_arithmetic_ops_aborts()
        return (0, 0)
        function A2_M_test_arithmetic_ops_aborts() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t7 := 100
                    /// @src 2:2379:2382
                    $t7 := 100
                    // abort($t7)
                    /// @src 2:2362:2383
                    $Abort($t7)
                }
                case 3 {
                    // label L0
                    // $t8 := 3
                    /// @src 2:2407:2408
                    $t8 := 3
                    // $t9 := ==($t4, $t8)
                    /// @src 2:2404:2406
                    $t9 := $Eq($t4, $t8)
                    // if ($t9) goto L2 else goto L3
                    /// @src 2:2393:2414
                    switch $t9
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 3
                    /// @src 2:2350:2351
                    $t2 := 3
                    // ($t3, $t4) := M::arithmetic_ops($t2)
                    /// @src 2:2335:2352
                    $t3, $t4 := A2_M_arithmetic_ops($t2)
                    // $t5 := 1
                    /// @src 2:2376:2377
                    $t5 := 1
                    // $t6 := ==($t3, $t5)
                    /// @src 2:2373:2375
                    $t6 := $Eq($t3, $t5)
                    // if ($t6) goto L0 else goto L1
                    /// @src 2:2362:2383
                    switch $t6
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t10 := 101
                    /// @src 2:2410:2413
                    $t10 := 101
                    // abort($t10)
                    /// @src 2:2393:2414
                    $Abort($t10)
                }
                case 6 {
                    // label L2
                    // return ()
                    /// @src 2:2414:2415
                    leave
                }
            }
        }

        function A2_M_arithmetic_ops(a) -> $result0, $result1 {
            let c, $t2, $t3, $t4, $t5
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // $t5 := 42
                    /// @src 2:2232:2234
                    $t5 := 42
                    // abort($t5)
                    /// @src 2:2226:2234
                    $Abort($t5)
                }
                case 3 {
                    // label L2
                    // return ($t2, $t0)
                    /// @src 2:2244:2250
                    $result0 := $t2
                    $result1 := a
                    leave
                }
                case 4 {
                    // $t2 := 2
                    /// @src 2:2181:2204
                    $t2 := 2
                    // $t3 := 2
                    /// @src 2:2223:2224
                    $t3 := 2
                    // $t4 := !=($t2, $t3)
                    /// @src 2:2220:2222
                    $t4 := $Neq($t2, $t3)
                    // if ($t4) goto L0 else goto L2
                    /// @src 2:2214:2234
                    switch $t4
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $Neq(x, y) -> r {
            r := not(eq(x, y))
        }
    }
}
===> Revert(Reverted) (used_gas=285): [0, 0, 0, 0, 0, 0, 0, 42]

// test of M::test_bool_ops
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_bool_ops" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_bool_ops()
        return (0, 0)
        function A2_M_test_bool_ops() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    /// @src 2:2004:2007
                    $t8 := 100
                    // abort($t8)
                    /// @src 2:1984:2008
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := false
                    /// @src 2:2032:2037
                    $t9 := false
                    // $t10 := ==($t5, $t9)
                    /// @src 2:2029:2031
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    /// @src 2:2018:2043
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 3
                    /// @src 2:1969:1970
                    $t2 := 3
                    // $t3 := 2
                    /// @src 2:1972:1973
                    $t3 := 2
                    // ($t4, $t5) := M::bool_ops($t2, $t3)
                    /// @src 2:1960:1974
                    $t4, $t5 := A2_M_bool_ops($t2, $t3)
                    // $t6 := true
                    /// @src 2:1998:2002
                    $t6 := true
                    // $t7 := ==($t4, $t6)
                    /// @src 2:1995:1997
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    /// @src 2:1984:2008
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    /// @src 2:2039:2042
                    $t11 := 101
                    // abort($t11)
                    /// @src 2:2018:2043
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    /// @src 2:2043:2044
                    leave
                }
            }
        }

        function A2_M_bool_ops(a, b) -> $result0, $result1 {
            let tmp_$2, tmp_$3, c, d, $t6, $t7, $t8, $t9, $t10, $t11, $t12
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // $t2 := >=($t0, $t1)
                    /// @src 2:1806:1808
                    tmp_$2 := $GtEq(a, b)
                    // goto L3
                    /// @src 2:1795:1810
                    $block := 5
                }
                case 3 {
                    // label L2
                    // $t7 := false
                    /// @src 2:1795:1810
                    $t7 := false
                    // $t2 := $t7
                    /// @src 2:1795:1810
                    tmp_$2 := $t7
                    // goto L3
                    /// @src 2:1795:1810
                    $block := 5
                }
                case 4 {
                    // $t6 := >($t0, $t1)
                    /// @src 2:1797:1798
                    $t6 := $Gt(a, b)
                    // if ($t6) goto L0 else goto L2
                    /// @src 2:1795:1810
                    switch $t6
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L3
                    // $t8 := <($t0, $t1)
                    /// @src 2:1826:1827
                    $t8 := $Lt(a, b)
                    // if ($t8) goto L4 else goto L6
                    /// @src 2:1824:1839
                    switch $t8
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // $t9 := true
                    /// @src 2:1824:1839
                    $t9 := true
                    // $t3 := $t9
                    /// @src 2:1824:1839
                    tmp_$3 := $t9
                    // goto L7
                    /// @src 2:1824:1839
                    $block := 8
                }
                case 7 {
                    // label L6
                    // $t3 := <=($t0, $t1)
                    /// @src 2:1835:1837
                    tmp_$3 := $LtEq(a, b)
                    // goto L7
                    /// @src 2:1824:1839
                    $block := 8
                }
                case 8 {
                    // label L7
                    // $t10 := !=($t2, $t3)
                    /// @src 2:1857:1859
                    $t10 := $Neq(tmp_$2, tmp_$3)
                    // $t11 := !($t10)
                    /// @src 2:1853:1854
                    $t11 := $LogicalNot($t10)
                    // if ($t11) goto L8 else goto L10
                    /// @src 2:1849:1872
                    switch $t11
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L8
                    // $t12 := 42
                    /// @src 2:1870:1872
                    $t12 := 42
                    // abort($t12)
                    /// @src 2:1864:1872
                    $Abort($t12)
                }
                case 10 {
                    // label L10
                    // return ($t2, $t3)
                    /// @src 2:1882:1888
                    $result0 := tmp_$2
                    $result1 := tmp_$3
                    leave
                }
            }
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $Gt(x, y) -> r {
            r := gt(x, y)
        }
        function $Lt(x, y) -> r {
            r := lt(x, y)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $LtEq(x, y) -> r {
            r := or(lt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $Neq(x, y) -> r {
            r := not(eq(x, y))
        }
        function $LogicalNot(x) -> r {
            r := not(x)
        }
    }
}
===> Succeed(Stopped) (used_gas=1228): []

// test of M::test_div
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_div" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_div()
        return (0, 0)
        function A2_M_test_div() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    /// @src 2:962:965
                    $t8 := 100
                    // abort($t8)
                    /// @src 2:945:966
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 3
                    /// @src 2:990:991
                    $t9 := 3
                    // $t10 := ==($t5, $t9)
                    /// @src 2:987:989
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    /// @src 2:976:997
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 7
                    /// @src 2:930:931
                    $t2 := 7
                    // $t3 := 4
                    /// @src 2:933:934
                    $t3 := 4
                    // ($t4, $t5) := M::div($t2, $t3)
                    /// @src 2:926:935
                    $t4, $t5 := A2_M_div($t2, $t3)
                    // $t6 := 1
                    /// @src 2:959:960
                    $t6 := 1
                    // $t7 := ==($t4, $t6)
                    /// @src 2:956:958
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    /// @src 2:945:966
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    /// @src 2:993:996
                    $t11 := 101
                    // abort($t11)
                    /// @src 2:976:997
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    /// @src 2:997:998
                    leave
                }
            }
        }

        function A2_M_div(x, y) -> $result0, $result1 {
            let $t2, $t3
            // $t2 := /($t0, $t1)
            /// @src 2:848:849
            $t2 := $Div(x, y)
            // $t3 := %($t0, $t1)
            /// @src 2:855:856
            $t3 := $Mod(x, y)
            // return ($t2, $t3)
            /// @src 2:845:859
            $result0 := $t2
            $result1 := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Div(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := div(x, y)
        }
        function $Mod(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := mod(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Succeed(Stopped) (used_gas=355): []

// test of M::test_div_by_zero
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_div_by_zero" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_div_by_zero()
        return (0, 0)
        function A2_M_test_div_by_zero() {
            let _r1, _r2, $t2, $t3, $t4, $t5
            // $t2 := 7
            /// @src 2:1231:1232
            $t2 := 7
            // $t3 := 0
            /// @src 2:1234:1235
            $t3 := 0
            // ($t4, $t5) := M::div($t2, $t3)
            /// @src 2:1227:1236
            $t4, $t5 := A2_M_div($t2, $t3)
            // destroy($t5)
            /// @src 2:1220:1223
            // destroy($t4)
            /// @src 2:1215:1218
            // return ()
            /// @src 2:1236:1237
        }

        function A2_M_div(x, y) -> $result0, $result1 {
            let $t2, $t3
            // $t2 := /($t0, $t1)
            /// @src 2:848:849
            $t2 := $Div(x, y)
            // $t3 := %($t0, $t1)
            /// @src 2:855:856
            $t3 := $Mod(x, y)
            // return ($t2, $t3)
            /// @src 2:845:859
            $result0 := $t2
            $result1 := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Div(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := div(x, y)
        }
        function $Mod(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := mod(x, y)
        }
    }
}
===> Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]

// test of M::test_div_wrong_assert
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_div_wrong_assert" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_div_wrong_assert()
        return (0, 0)
        function A2_M_test_div_wrong_assert() {
            let r1, r2, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t8 := 100
                    /// @src 2:1114:1117
                    $t8 := 100
                    // abort($t8)
                    /// @src 2:1097:1118
                    $Abort($t8)
                }
                case 3 {
                    // label L0
                    // $t9 := 2
                    /// @src 2:1142:1143
                    $t9 := 2
                    // $t10 := ==($t5, $t9)
                    /// @src 2:1139:1141
                    $t10 := $Eq($t5, $t9)
                    // if ($t10) goto L2 else goto L3
                    /// @src 2:1128:1149
                    switch $t10
                    case 0  { $block := 5 }
                    default { $block := 6 }
                }
                case 4 {
                    // $t2 := 7
                    /// @src 2:1082:1083
                    $t2 := 7
                    // $t3 := 4
                    /// @src 2:1085:1086
                    $t3 := 4
                    // ($t4, $t5) := M::div($t2, $t3)
                    /// @src 2:1078:1087
                    $t4, $t5 := A2_M_div($t2, $t3)
                    // $t6 := 1
                    /// @src 2:1111:1112
                    $t6 := 1
                    // $t7 := ==($t4, $t6)
                    /// @src 2:1108:1110
                    $t7 := $Eq($t4, $t6)
                    // if ($t7) goto L0 else goto L1
                    /// @src 2:1097:1118
                    switch $t7
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
                case 5 {
                    // label L3
                    // $t11 := 101
                    /// @src 2:1145:1148
                    $t11 := 101
                    // abort($t11)
                    /// @src 2:1128:1149
                    $Abort($t11)
                }
                case 6 {
                    // label L2
                    // return ()
                    /// @src 2:1149:1150
                    leave
                }
            }
        }

        function A2_M_div(x, y) -> $result0, $result1 {
            let $t2, $t3
            // $t2 := /($t0, $t1)
            /// @src 2:848:849
            $t2 := $Div(x, y)
            // $t3 := %($t0, $t1)
            /// @src 2:855:856
            $t3 := $Mod(x, y)
            // return ($t2, $t3)
            /// @src 2:845:859
            $result0 := $t2
            $result1 := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Div(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := div(x, y)
        }
        function $Mod(x, y) -> r {
            if eq(y, 0) { $AbortBuiltin() }
            r := mod(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Revert(Reverted) (used_gas=348): [0, 0, 0, 0, 0, 0, 0, 101]

// test of M::test_multiple_ops
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_multiple_ops" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_multiple_ops()
        return (0, 0)
        function A2_M_test_multiple_ops() {
            let r, $t1, $t2, $t3, $t4, $t5, $t6, $t7
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t7 := 100
                    /// @src 2:1482:1485
                    $t7 := 100
                    // abort($t7)
                    /// @src 2:1458:1486
                    $Abort($t7)
                }
                case 3 {
                    // label L0
                    // return ()
                    /// @src 2:1486:1487
                    leave
                }
                case 4 {
                    // $t1 := 3
                    /// @src 2:1440:1441
                    $t1 := 3
                    // $t2 := 2
                    /// @src 2:1443:1444
                    $t2 := 2
                    // $t3 := 5
                    /// @src 2:1446:1447
                    $t3 := 5
                    // $t4 := M::multiple_ops($t1, $t2, $t3)
                    /// @src 2:1427:1448
                    $t4 := A2_M_multiple_ops($t1, $t2, $t3)
                    // $t5 := 13
                    /// @src 2:1471:1480
                    $t5 := 13
                    // $t6 := ==($t4, $t5)
                    /// @src 2:1468:1470
                    $t6 := $Eq($t4, $t5)
                    // if ($t6) goto L0 else goto L1
                    /// @src 2:1458:1486
                    switch $t6
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
            }
        }

        function A2_M_multiple_ops(x, y, z) -> $result {
            let $t3, $t4
            // $t3 := *($t1, $t2)
            /// @src 2:1358:1359
            $t3 := $MulU64(y, z)
            // $t4 := +($t0, $t3)
            /// @src 2:1354:1355
            $t4 := $AddU64(x, $t3)
            // return $t4
            /// @src 2:1352:1361
            $result := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $MulU64(x, y) -> r {
            if gt(y, div(0xffffffffffffffff, x)) { $AbortBuiltin() }
            r := mul(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Succeed(Stopped) (used_gas=176): []

// test of M::test_multiple_overflow
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_multiple_overflow" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_multiple_overflow()
        return (0, 0)
        function A2_M_test_multiple_overflow() {
            let r, $t1, $t2, $t3, $t4, $t5, $t6, $t7
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t7 := 100
                    /// @src 2:1627:1630
                    $t7 := 100
                    // abort($t7)
                    /// @src 2:1611:1631
                    $Abort($t7)
                }
                case 3 {
                    // label L0
                    // return ()
                    /// @src 2:1631:1632
                    leave
                }
                case 4 {
                    // $t1 := 0
                    /// @src 2:1574:1575
                    $t1 := 0
                    // $t2 := 18446744073709551615
                    /// @src 2:1577:1597
                    $t2 := 18446744073709551615
                    // $t3 := 2
                    /// @src 2:1599:1600
                    $t3 := 2
                    // $t4 := M::multiple_ops($t1, $t2, $t3)
                    /// @src 2:1561:1601
                    $t4 := A2_M_multiple_ops($t1, $t2, $t3)
                    // $t5 := 0
                    /// @src 2:1624:1625
                    $t5 := 0
                    // $t6 := ==($t4, $t5)
                    /// @src 2:1621:1623
                    $t6 := $Eq($t4, $t5)
                    // if ($t6) goto L0 else goto L1
                    /// @src 2:1611:1631
                    switch $t6
                    case 0  { $block := 2 }
                    default { $block := 3 }
                }
            }
        }

        function A2_M_multiple_ops(x, y, z) -> $result {
            let $t3, $t4
            // $t3 := *($t1, $t2)
            /// @src 2:1358:1359
            $t3 := $MulU64(y, z)
            // $t4 := +($t0, $t3)
            /// @src 2:1354:1355
            $t4 := $AddU64(x, $t3)
            // return $t4
            /// @src 2:1352:1361
            $result := $t4
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $AddU64(x, y) -> r {
            if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $MulU64(x, y) -> r {
            if gt(y, div(0xffffffffffffffff, x)) { $AbortBuiltin() }
            r := mul(x, y)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
    }
}
===> Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]

// test of M::test_underflow
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 2:"tests/Arithm.move"


object "test_A2_M_test_underflow" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_underflow()
        return (0, 0)
        function A2_M_test_underflow() {
            let _r, $t1
            // $t1 := M::underflow()
            /// @src 2:2604:2615
            $t1 := A2_M_underflow()
            // destroy($t1)
            /// @src 2:2599:2601
            // return ()
            /// @src 2:2615:2616
        }

        function A2_M_underflow() -> $result {
            let x, $t1, $t2, $t3
            // $t1 := 0
            /// @src 2:2521:2522
            $t1 := 0
            // $t2 := 1
            /// @src 2:2536:2537
            $t2 := 1
            // $t3 := -($t1, $t2)
            /// @src 2:2534:2535
            $t3 := $Sub($t1, $t2)
            // return $t3
            /// @src 2:2532:2537
            $result := $t3
        }

        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Sub(x, y) -> r {
            if lt(x, y) { $AbortBuiltin() }
            r := sub(x, y)
        }
    }
}
===> Revert(Reverted) (used_gas=21): [255, 255, 255, 255, 255, 255, 255, 255]
